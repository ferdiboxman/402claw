name: Risk Policy Gate

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  risk-policy-gate:
    name: Risk Policy Gate
    runs-on: ubuntu-latest
    outputs:
      risk-tier: ${{ steps.classify.outputs.tier }}
      required-checks: ${{ steps.classify.outputs.required-checks }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get changed files
        id: changed
        uses: tj-actions/changed-files@v44
        with:
          json: true

      - name: Classify risk tier
        id: classify
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // Load risk policy
          const policyPath = path.join(process.cwd(), 'risk-policy.json');
          if (!fs.existsSync(policyPath)) {
            console.log('No risk-policy.json found, defaulting to medium');
            console.log('::set-output name=tier::medium');
            console.log('::set-output name=required-checks::["risk-policy-gate","ci-pipeline"]');
            process.exit(0);
          }
          
          const policy = JSON.parse(fs.readFileSync(policyPath, 'utf8'));
          const changedFiles = JSON.parse(process.env.CHANGED_FILES || '[]');
          
          // Determine highest risk tier
          const tiers = ['critical', 'high', 'medium', 'low'];
          let highestTier = 'low';
          
          for (const file of changedFiles) {
            for (const tier of tiers) {
              const patterns = policy.riskTierRules[tier]?.paths || [];
              for (const pattern of patterns) {
                const regex = new RegExp(pattern.replace(/\*\*/g, '.*').replace(/\*/g, '[^/]*'));
                if (regex.test(file)) {
                  if (tiers.indexOf(tier) < tiers.indexOf(highestTier)) {
                    highestTier = tier;
                  }
                }
              }
            }
          }
          
          const requiredChecks = policy.mergePolicy[highestTier]?.requiredChecks || [];
          
          console.log(`Risk tier: ${highestTier}`);
          console.log(`Required checks: ${JSON.stringify(requiredChecks)}`);
          
          // GitHub Actions output
          const output = `tier=${highestTier}\nrequired-checks=${JSON.stringify(requiredChecks)}`;
          fs.appendFileSync(process.env.GITHUB_OUTPUT, output);
          EOF
        env:
          CHANGED_FILES: ${{ steps.changed.outputs.all_changed_files }}

      - name: Add risk tier label
        uses: actions/github-script@v7
        with:
          script: |
            const tier = '${{ steps.classify.outputs.tier }}';
            const labels = {
              critical: 'risk:critical',
              high: 'risk:high',
              medium: 'risk:medium',
              low: 'risk:low'
            };
            
            // Remove existing risk labels
            const currentLabels = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            for (const label of currentLabels.data) {
              if (label.name.startsWith('risk:')) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: label.name
                });
              }
            }
            
            // Add new risk label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [labels[tier]]
            });

      - name: Post risk summary
        uses: actions/github-script@v7
        with:
          script: |
            const tier = '${{ steps.classify.outputs.tier }}';
            const checks = JSON.parse('${{ steps.classify.outputs.required-checks }}');
            
            const tierEmoji = {
              critical: 'ðŸ”´',
              high: 'ðŸŸ ',
              medium: 'ðŸŸ¡',
              low: 'ðŸŸ¢'
            };
            
            const body = `## ${tierEmoji[tier]} Risk Assessment: ${tier.toUpperCase()}

            **Required checks for merge:**
            ${checks.map(c => `- [ ] ${c}`).join('\n')}

            <!-- risk-policy-gate-sha:${{ github.event.pull_request.head.sha }} -->
            `;
            
            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const existingComment = comments.data.find(c => 
              c.body.includes('<!-- risk-policy-gate-sha:')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Check if human review required
        if: steps.classify.outputs.tier == 'critical'
        run: |
          echo "::warning::This PR touches critical paths and requires human review before merge"
